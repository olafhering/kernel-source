From: NeilBrown <neilb@suse.de>
Subject: Fix error in kabi fix for: NFSv4: Fix OPEN / CLOSE race
References: bsc#1176950
Patch-mainline: Never, kabi

As we now use a shared waitqueue, we could get extra wakeups.  In the
worst case we could get spurious wakeups at shorted intervals than 5*HZ,
so we never seem to timeout, and so loop indefinitely.

So calculate the expected deadline time, and once we pass that time,
assume a timeout.

Signed-off-by: NeilBrown <neilb@suse.com>
---
 fs/nfs/nfs4proc.c |    4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -1516,6 +1516,7 @@ static void nfs_clear_open_stateid(struc
 static void nfs_set_open_stateid_locked(struct nfs4_state *state,
 		const nfs4_stateid *stateid, nfs4_stateid *freeme)
 {
+	unsigned long deadline = jiffies + 5 * HZ;
 	DEFINE_WAIT(wait);
 	struct wait_queue_head *wq_head = bit_waitqueue(&state->flags,
 							NFS_STATE_CHANGE_WAIT);
@@ -1542,7 +1543,8 @@ static void nfs_set_open_stateid_locked(
 		spin_unlock(&state->owner->so_lock);
 		rcu_read_unlock();
 		if (!signal_pending(current)) {
-			if (schedule_timeout(5*HZ) == 0)
+			if (schedule_timeout(5*HZ) == 0 ||
+			    time_after(jiffies, deadline))
 				status = -EAGAIN;
 			else
 				status = 0;
